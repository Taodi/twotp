<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Twisted as an Erlang node</title>
  </head>

  <body>
    <h1>Twisted as an Erlang node</h1>

    <h2>Prequesites</h2>

    <p>
        In this document, we'll assume that you have a basic knowledge of
        Twisted (how to create a client, how to create a server, what is
        the protocol/factory mechanism, what is a deferred), and of Erlang
        (what is a node, what is the EPMD, what are the basic types). Please
        refer to the respective documentation if it's not the case.
    </p>

    <h2>Invoking methods on an Erlang node</h2>

    <p>
        To create connection to an erlang node, you'll need to get the cookie
        and create a node name. The utility functions
        <code class="API" base="twotp.node">readCookie</code>
        and  <code class="API" base="twotp.node">buildNodeName</code>
        are here to help you out: the first read the cookie at the usual
        place ($HOME/.erlang.cookie), the second append the name of the
        host to the name you have chosen.
    </p>

    <p>
        Then, instantiate the class
        <code class="API" base="twotp.node">Process</code>
        with the infos, and call callRemote on it. This method will:
        <ul>
            <li>create a connection with the EPMD</li>
            <li>ask for the port info of the node</li>
            <li>connect to the node</li>
            <li>return the connected node client protocol</li>
            <li>make a RPC call on the connected node</li>
            <li>return the result to you</li>
        </ul>
    </p>

    <pre class="python">
from twisted.internet import reactor
from twotp import Process, readCookie, buildNodeName


def gotResult(resp):
    print "Got response", resp
    reactor.stop()


def eb(error):
    print "Got error", error
    reactor.stop()


cookie = readCookie()
nodeName = buildNodeName('nodename')
process = Process(nodeName, cookie)
process.callRemote("foo", "file", "get_cwd").addCallback(gotResult).addErrback(eb)
reactor.run()
    </pre>

    <h2>Instantiating a node</h2>

    <p>
        The process for creating a node is really straightforward: you just
        have to call the <code>listen</code> of your <code>Process</code>.
        What happens behind the scene is that first it creates a node server
        factory, and makes it listen on an arbitrary port. Then it creates a
        client connection to the EPMD, giving the server port as argument.

        The EPMD should be started outside Twisted. It is
        started automatically when you start an erlang application.
    </p>

    <pre class="python">
import sys
from twisted.python import log
from twisted.internet import reactor
from twotp import Process, readCookie, buildNodeName

cookie = readCookie()
nodeName = buildNodeName('nodename')
log.startLogging(sys.stdout)
process = Process(nodeName, cookie)
process.listen()
reactor.run()
    </pre>

    <p>
        Of course, for now it does nothing useful, so we now see how to
        get data from an erlang nodes.
    </p>


    <h2>Receiving method calls from an Erlang node</h2>

    <p>
        The key method here is the method <code>registerModule</code> of the
        <code>Process</code> class: this method takes a name and an object. The
        name is the name of the module used when making a call from Erlang. The
        object is an instance of a class with methods prefixed by
        <code>remote_</code>.
    </p>

    <pre class="python">
import sys
from twisted.python import log
from twisted.internet import reactor
from twotp import Process, readCookie, buildNodeName

class Proxy(object):
    def remote_double(self, arg):
        return arg * 2

cookie = readCookie()
nodeName = buildNodeName('nodename')
log.startLogging(sys.stdout)
process = Process(nodeName, cookie)
process.registerModule("math", Proxy())
process.listen()
reactor.run()
    </pre>

    <p>
        The script above define a <code>Proxy</code> with a
        <code>remote_double</code> method. We can publish with the keyword
        math, which creates a module named math with the method double. We can
        now call this method in an Erlang console:
    </p>

    <pre>
(erlang@node)1> rpc:call('nodename@node', math, double, [3]).
{ok,6}
    </pre>

    <h2>An example: using a Mnesia database</h2>

    <p>
        To try the communication as client, we'll set up a mnesia database to
        be used within a Twisted application. Please refer to the mnesia
        documentation for further information. Note that there is nothing new
        here: it's just a concrete example to put the things together.
    </p>

    <p>
        First create a file named twisted.hrl with following record:
    </p>

    <pre class="erlang">
-record(user, {id, name}).
    </pre>

    <p>
        Then create a file named twisted.erl
    </p>

    <pre class="erlang">
-module(twisted).
-export([init/0, insert_user/2, get_user/1]).
-include("twisted.hrl").

init() ->
    mnesia:create_table(user,
                        [{attributes, record_info(fields, user)}]).

insert_user(UserName, UserId) ->
    User = #user{id=UserId, name=UserName},
    Fun = fun() ->
            mnesia:write(User)
        end,
    mnesia:transaction(Fun).

get_user(UserId) ->
    Fun = fun() ->
            [User] = mnesia:read(user, UserId, read),
            User
        end,
    case mnesia:transaction(Fun) of
        {atomic, User} ->
            User
    end.
    </pre>

    <p>
        Now fire an erlang interpreter. We'll compile the twisted file, start
        the mnesia database, create the table, and insert a test user.
    </p>

    <pre class="shell">
$ erl -sname twisted_mnesia

(twisted_mnesia@localhost)1> c(twisted).
{ok,twisted}
(twisted_mnesia@localhost)2> mnesia:start().
ok
(twisted_mnesia@localhost)3> twisted:init().
{atomic,ok}
(twisted_mnesia@localhost)4> twisted:insert_user(test1, 1).
{atomic,ok}
(twisted_mnesia@localhost)5> twisted:get_user(1).
{user,1,test1}
    </pre>

    <p>
        The node is ready to accept our python calls.
    </p>

    <pre class="python">
from twisted.internet import reactor
from twotp import Process, readCookie, buildNodeName

def gotResult(resp):
    print "Got response", resp
    reactor.stop()

def eb(error):
    print "Got error", error
    reactor.stop()

cookie = readCookie()
nodeName = buildNodeName('nodename')
process = Process(nodeName, cookie)
process.callRemote("twisted_mnesia", "twisted", "get_user", 1
    ).addCallback(gotResult).addErrback(eb)

reactor.run()
    </pre>

    <p>
        If everything is fine, you should get the following response:
    </p>

    <pre class="shell">
Got response (&lt;Atom at -0x48806e54, text 'user'&gt;, 1, &lt;Atom at -0x48806e74, text 'test1'&gt;)
    </pre>

  </body>
</html>

